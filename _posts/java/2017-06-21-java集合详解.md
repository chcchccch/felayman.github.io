---
layout: post
title:  "java集合详解"
date:   2017-06-21 13:41:01 +0800
categories: java
tag: java 原创
sid: 1498021585
---

> 最近在对项目中关于对java集合使用场景进行Code Review梳理,发现项目中的确在对java集合不够深入理解的前提下,随意滥用集合类,在此对java集合进行一次深入梳理.

## Collection接口 持有单个元素集合的顶级接口,定义了对元素集合的最基本操作

> The root interface in the <i>collection hierarchy</i>.  A collection
represents a group of objects, known as its <i>elements</i>.  Some
collections allow duplicate elements and others do not.  Some are ordered
and others unordered.  The JDK does not provide any <i>direct</i>
implementations of this interface: it provides implementations of more
specific subinterfaces like <tt>Set</tt> and <tt>List</tt>.  This interface
is typically used to pass collections around and manipulate them where
maximum generality is desired.

  **主要方法有:**
  - int size()  集合元素大小
  - boolean isEmpty()  是否为空集合
  - boolean contains(Object o) 该集合是否包含指定对象
  - Iterator<E> iterator()  该该集合进行迭代
  - Object[] toArray()  将该集合转换成一个数组对象
  - <T> T[] toArray(T[] a) 将该集合转换成一个数组对象,并与指定的对象数组合并
  - boolean add(E e)            往集合中添加元素
  - boolean remove(Object o) 在集合中删除指定元素
  - boolean containsAll(Collection<?> c)    判断该集合是否包含另外一个集合
  - boolean addAll(Collection<? extends E> c)  将另一个集合合并到当前集合中
  - boolean removeAll(Collection<?> c) 在当前集合中删除指定集合
  - boolean retainAll(Collection<?> c) 判断当前集合是否只有指定集合
  - void clear()        清除该集合
  - boolean equals(Object o)  比较两个集合是否一样


## AbstractCollection抽象类,实现Collection接口中的部分方法

**实现的方法有:**
- public boolean isEmpty()
- public boolean contains(Object o)
- public Object[] toArray()
- public <T> T[] toArray(T[] a)
- public boolean remove(Object o)
- public boolean containsAll(Collection<?> c)
- public boolean addAll(Collection<? extends E> c)
- public boolean removeAll(Collection<?> c)
- public boolean retainAll(Collection<?> c)
- public void clear()

这些方法对所有AbstractCollection子类的实现方式是一致的,除非有特殊操作要求,一般情况下使用该抽象类默认的实现即可。

## List接口,实现Collection接口(An ordered collection)

List接口是Collection接口的一种扩展,一种有序集合(An ordered collection),细心的人可以发现,List接口重新定义了Collection中的一些方法,对java多态理解比较浅的人
可能会有这样的想法:
>  List接口不是会自动继承Collection中的方法吗?为什么还需要在List中要重新定义这些方法呢?

这个问题还 有待商榷！！！！

List接口中除了保留Collection接口中定义的一些方法外,扩展了对集合的添加与获取操作

**扩展的方法有:**
-  E get(int index)  获取指定位置上的元素
- E set(int index, E element) 设置指定位置上的元素为指定元素
- E remove(int index)  删除指定位置上的元素
- int indexOf(Object o) 获取指定对象在集合中的第一次出现位置
- int lastIndexOf(Object o) 获取指定对象在集合中的最后一次出现位置
- ListIterator<E> listIterator() 获取list的迭代器
- ListIterator<E> listIterator(int index) 获取list的迭代器,但是只是迭代到指定位置
- List<E> subList(int fromIndex, int toIndex) 截取指定区间的元素列表

我们可以看到List接口主要扩展了对集合元素的读写操作。

## Set接口,实现Collection接口(A collection that contains no duplicate elements)

Set接口本身没有对Collection进行扩展,只是重新定义了Collection中的方法,并申明该接口是可以存储重复元素的集合,这里又抛出了一个问题.
> 既然Set继承了Collection接口,就继承了Collection接口已经有的方法,为什么还要再次重新定义这些方法呢?
这个问题还 有待商榷！！！！

从接口定义中就可以看出List与Set(包含两者实现的子类)的区别:
1. Set 不允许重复,List允许重复
2. Set 没有顺序,List有顺序(这点并不是主要的,有具体子类可以实现有序的Set)


## Queue接口,实现Collection接口(A collection designed for holding elements prior to processing)

Queue接口继承Collection接口,在原有的基础上,扩展了一些插入,取出,检查等操作

**主要方法有:**
- boolean add(E e)      将指定的元素插入此队列
- boolean offer(E e) 将指定的元素插入此队列（如果立即可行且不会违反容量限制），当使用有容量限制的队列时，此方法通常要优于 add(E)，后者可能无法插入元素，而只是抛出一个异常
- E remove()    获取并移除此队列的头
- E poll()  获取并移除此队列的头，如果此队列为空，则返回 null
- E element() 获取，但是不移除此队列的头
- E peek() 获取但不移除此队列的头；如果此队列为空，则返回 null


##  AbstractList,AbstractSet 对List接口和Set接口的部分实现的抽象子类


## Map接口(An object that maps keys to values) 存储key-value结构的数据结构

**主要方法有:**
- int size() map的大小
- boolean isEmpty() 判断map是否为空
- boolean containsKey(Object key) 是否包含指定的key
- boolean containsValue(Object value) 是否包含指定的value
- V get(Object key) 获取指定key的value
- V put(K key, V value) 添加key-value
- V remove(Object key) 删除指定key
- void putAll(Map<? extends K, ? extends V> m) 将另一个map合并到当前map
-  void clear() 清除map中的元素
- Set<K> keySet() 获取map中的key的集合
- Collection<V> values() 获取map中value的集合

从最后两个方法中可以看出map的key不能有重复的元素,value则可以有重复的元素


## 上面是集合的主要接口,关于这些接口,JDK都提供了不同数据结构实现的策略类,下面我们一起看看这些具体的实现类.


### List接口的主要实现类
- ArrayList 基于数组的列表,线程不安全的列表
- LinkedList 基于链表的列表
- Vector 基于数组的列表,但是线程安全,内部所有方法,都使用了synchronized
- Stack 基于Vector实现堆的操作


#### ArrayList  基于数组实现的列表

> public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable 这里AbstractList已经实现List接口,那么这里为什么ArrayList还要再次实现List呢?


ArrayList的数据结构:

~~~java
 private static final long serialVersionUID = 8683452581122892189L;
 private static final int DEFAULT_CAPACITY = 10;
 private static final Object[] EMPTY_ELEMENTDATA = {};
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
transient Object[] elementData;
private int size;
~~~

说白了,ArrayList就是利用一个可变的数组对象来完成列表操作.

ArrayList默认初始化:

~~~java
public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
~~~
就是创建了一个空的对象数组,等效于执行了Object[] elementData = new Object[0];

public boolean add(E e)的实现
~~~java
ensureCapacityInternal(size + 1);  // Increments modCount!!
elementData[size++] = e;
return true;
~~~
1. ensureCapacityInternal(size + 1)  内部通过数组复制的方式来新建一个新容量的数组对象
2. elementData[size++] = e 完成两个操作,1.在对象数组的下一个位置上存储指定元素 2. 改变数组长度(因为该操作非原子性,造成ArrayList是非线程安全的类)

线程安全的例子:
~~~java
class ListThread implements Runnable{
    private List<String> list ;
    private ListThread(){}
    public ListThread(List<String> list) {
        this.list = list;
    }
    @Override
    public void run() {
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        list.add(Thread.currentThread().getName());
//            System.out.println("list runtime size:"+list.size());
    }
}
public class ListDemo {
    static final int runtimeCount = 1000;
    static ExecutorService executorService = Executors.newFixedThreadPool(runtimeCount);
    public static void main(String [] args) throws InterruptedException {
        List<String> list = new ArrayList<>();
        for (int i = 1; i <= runtimeCount; i++) {
            executorService.submit(new ListThread(list));
        }
        Thread.sleep(1000L);
        System.out.println("list run over size :"+list.size());
        System.exit(-1);
    }
}
~~~

打印出的结果中,并非是99,很有可能是一个小于99的值,当修改runtimeCount的值,该值越大意味着并发越高,则出现异常的几率越大,

> 当多个线程同时对一个list进行操作,如调用add方法的时候,在还没有完成对size的++操作的时候(add(E e)方法不是线程安全的),就调用了size()方法,就导致线程冲突,就是list的大小的确是99,但是却返回了一个小于99的值,这肯定会影响程序


想要避免此类线程安全问题,有两个方式:
1. 使用List<String> list = Collections.synchronizedList(new ArrayList<>());  创建一个线程安全的List
2. List<String> list = new Vector<>() Vector类内部所有方法都使用了synchronized来保证每个方法调用都是原子操作

两者都保证了对List的线程安全操作,原理上是一样的,都是通过对象锁来保证(前者是通过同步代码块,后者是通过同步方法,本质上一致的)
**同步方法:**
~~~java
 public synchronized boolean add(E e) {
        modCount++;
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = e;
        return true;
    }
~~~


**同步代码块:**
~~~java
public boolean add(E e) {
            synchronized (mutex) {return c.add(e);}
        }
~~~

关于同步方法和同步代码块的异同,详情看:[SynchronizedList和Vector的区别](http://www.hollischuang.com/archives/498)

未完待续......